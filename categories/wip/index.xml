<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wip on KELEUSTES&#39;s Blog</title>
    <link>https://keleustes.github.io/categories/wip/</link>
    <description>Recent content in Wip on KELEUSTES&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 15 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://keleustes.github.io/categories/wip/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>CRDs</title>
      <link>https://keleustes.github.io/armada-operator/children/crds/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://keleustes.github.io/armada-operator/children/crds/</guid>
      <description>CRDs ArmadaChart CRD The ArmadaChart defintion used in production is available here: Production
The CRD ArmadaChart definition is available here:
 Its Spec which is update through kubectl: Spec Its Status which is updated by the operator and accessible through kubectl describe: Status Its definition made out of the two above components: Definition The yaml version of the CRD: Yaml  ArmadaChartGroup CRD The ArmadaChartGroup defintion used in production is available here: Production</description>
    </item>
    
    <item>
      <title>Deployment Flows</title>
      <link>https://keleustes.github.io/armada-operator/children/operator/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://keleustes.github.io/armada-operator/children/operator/</guid>
      <description>Deployment Flows CRDs in Deckhand In the Airship used for production deployment, the SiteManifest could be viewed as a composition of Custom Resources:
 &amp;ldquo;Drydock&amp;rdquo; CR describing the kubernetes nodes, network, kublet. &amp;ldquo;ArmadaChart&amp;rdquo; CR describing the location of the helm chart and the helm chart value override.  Shipyard, Drydock and Armada are orchestrating the order of deployment:
 BareMetal OS, Network Docker, Kubelet, Kubernetes Storage, CEPH Applications for instance MariaDB  In the subsequent drawings, red arrows represent APIs and CLI calls (arship or kubernetes calls), blue arrows represents events generated by K8s.</description>
    </item>
    
    <item>
      <title>FlowCharts</title>
      <link>https://keleustes.github.io/oslc-operator/children/flowcharts/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://keleustes.github.io/oslc-operator/children/flowcharts/</guid>
      <description>Greenfield Deployment Schema Rationale  Ops Team need to deploy a new service. If the service is unhealty, it gets removed. If the service is healty, it reaches the operational.  Brownfield Change Schema Rationale  Ops Team need to:
 Use Case 1: remove a service. Use Case 2: update a service. Use Case 3: rollback a service.  Once the traffic is drain:
 Use Case 1: the service is removed.</description>
    </item>
    
    <item>
      <title>Ideas</title>
      <link>https://keleustes.github.io/armada-operator/children/todo/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://keleustes.github.io/armada-operator/children/todo/</guid>
      <description>Ideas  Can we use the &amp;ldquo;finalizer&amp;rdquo; to implement the &amp;ldquo;protected&amp;rdquo; feature of ArmadaChart. We need a consistent handling of Conditions, Events and Status and behavior which are easily understood by people understanding K8s. &amp;ldquo;kubectl get act&amp;rdquo; should be able to return a synthetic view as good as the &amp;ldquo;kubectl get pod&amp;rdquo; does. The Status object should be accurate enough for the DAG in the Argo Workflow to stay simple.</description>
    </item>
    
    <item>
      <title>LifeCycle</title>
      <link>https://keleustes.github.io/oslc-operator/children/lifecycle/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://keleustes.github.io/oslc-operator/children/lifecycle/</guid>
      <description>Openstack Service Lifecycle Schema Rationale  Some transitions from one phase/stage to the other are autonomous:  Start to test if install successful) xxx  Some transitions from one phase/stage to the other but be triggered by Ops.  For instance, the traffic will not be drained from a site unless Ops needs to perform operations: xxx  Some of the lifecyle can be applied to one slice/shard of the a service.</description>
    </item>
    
    <item>
      <title>Oslc CRD</title>
      <link>https://keleustes.github.io/oslc-operator/children/oslc_crd/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://keleustes.github.io/oslc-operator/children/oslc_crd/</guid>
      <description>LifeCycle Modelisation Design Oslc CRD The CRD Oslc definition is available here:
 Its Spec which is update through kubectl: Spec Its Status which is updated by the operator and accessible through kubectl describe: Status Its definition made out of the two above components: Definition The yaml version of the CRD: Yaml  Oslc Controller TBD
SubResources The current PhaseCRD are currently standalone CRDs. This provides control to the phase-controller on those objects.</description>
    </item>
    
    <item>
      <title>Phase CRD</title>
      <link>https://keleustes.github.io/oslc-operator/children/phase_crd/</link>
      <pubDate>Wed, 15 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://keleustes.github.io/oslc-operator/children/phase_crd/</guid>
      <description>Phase Modelisation Design Phase CRD The CRD Phase definition is available here:
 Its Spec which is update through kubectl: Spec Its Status which is updated by the operator and accessible through kubectl describe: Status Its definition made out of the two above components: Definition The yaml version of the CRD: Yaml  Phase Controller The current POC created one CRD per phase. Most of the attributes of those CRDs are common.</description>
    </item>
    
  </channel>
</rss>